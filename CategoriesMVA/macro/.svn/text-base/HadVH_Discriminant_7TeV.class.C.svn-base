// Class: ReadBDTG
// Automatically generated by MethodBase::MakeClass
//

/* configuration options =====================================================

#GEN -*-*-*-*-*-*-*-*-*-*-*- general info -*-*-*-*-*-*-*-*-*-*-*-

Method         : BDT::BDTG
TMVA Release   : 4.1.4         [262404]
ROOT Release   : 5.34/10       [336394]
Creator        : gartoni
Date           : Fri Mar 14 11:45:02 2014
Host           : Linux lxbuild175.cern.ch 2.6.18-308.4.1.el5 #1 SMP Wed Apr 18 16:26:27 CEST 2012 x86_64 x86_64 x86_64 GNU/Linux
Dir            : /afs/cern.ch/user/g/gartoni/Training
Training events: 39609
Analysis type  : [Classification]


#OPT -*-*-*-*-*-*-*-*-*-*-*-*- options -*-*-*-*-*-*-*-*-*-*-*-*-

# Set by User:
V: "False" [Verbose output (short form of "VerbosityLevel" below - overrides the latter one)]
VarTransform: "Normalize" [List of variable transformations performed before training, e.g., "D_Background,P_Signal,G,N_AllClasses" for: "Decorrelation, PCA-transformation, Gaussianisation, Normalisation, each for the given class of events ('AllClasses' denotes all events of all classes, if no class indication is given, 'All' is assumed)"]
H: "False" [Print method-specific help message]
NTrees: "60" [Number of trees in the forest]
BoostType: "Grad" [Boosting type for the trees in the forest]
UseBaggedGrad: "True" [Use only a random subsample of all events for growing the trees in each iteration. (Only valid for GradBoost)]
GradBaggingFraction: "5.000000e-01" [Defines the fraction of events to be used in each iteration when UseBaggedGrad=kTRUE. (Only valid for GradBoost)]
Shrinkage: "7.000000e-01" [Learning rate for GradBoost algorithm]
nEventsMin: "200" [Minimum number of events required in a leaf node (default: Classification: max(40, N_train/(Nvar^2)/10), Regression: 10)]
nCuts: "20" [Number of steps during node cut optimisation]
PruneMethod: "costcomplexity" [Method used for pruning (removal) of statistically insignificant branches]
NNodesMax: "8" [Max number of nodes in tree]
MaxDepth: "5" [Max depth of the decision tree allowed]
# Default:
VerbosityLevel: "Default" [Verbosity level]
CreateMVAPdfs: "False" [Create PDFs for classifier outputs (signal and background)]
IgnoreNegWeightsInTraining: "False" [Events with negative weights are ignored in the training (but are included for testing and performance evaluation)]
RenormByClass: "False" [Individually re-normalize each event class to the original size after boosting]
AdaBoostR2Loss: "quadratic" [Type of Loss function in AdaBoostR2t (Linear,Quadratic or Exponential)]
AdaBoostBeta: "1.000000e+00" [Parameter for AdaBoost algorithm]
UseRandomisedTrees: "False" [Choose at each node splitting a random set of variables]
UseNvars: "2" [Number of variables used if randomised tree option is chosen]
UsePoissonNvars: "True" [Interpret "UseNvars" not as fixed number but as mean of a Possion distribution in each split]
UseNTrainEvents: "39609" [Number of randomly picked training events used in randomised (and bagged) trees]
UseWeightedTrees: "True" [Use weighted trees or simple average in classification from the forest]
UseYesNoLeaf: "True" [Use Sig or Bkg categories, or the purity=S/(S+B) as classification of the leaf node]
NodePurityLimit: "5.000000e-01" [In boosting/pruning, nodes with purity > NodePurityLimit are signal; background otherwise.]
SeparationType: "giniindex" [Separation criterion for node splitting]
UseFisherCuts: "False" [Use multivariate splits using the Fisher criterion]
MinLinCorrForFisher: "8.000000e-01" [The minimum linear correlation between two variables demanded for use in Fisher criterion in node splitting]
UseExclusiveVars: "False" [Variables already used in fisher criterion are not anymore analysed individually for node splitting]
PruneStrength: "0.000000e+00" [Pruning strength]
PruneBeforeBoost: "False" [Flag to prune the tree before applying boosting algorithm]
PruningValFraction: "5.000000e-01" [Fraction of events to use for optimizing automatic pruning.]
DoBoostMonitor: "False" [Create control plot with ROC integral vs tree number]
NegWeightTreatment: "ignorenegweights" [How to treat events with negative weights in the BDT training (particular the boosting) : Ignore;  Boost With inverse boostweight; Pair events with negative and positive weights in traning sample and *annihilate* them (experimental!); Randomly pair events with negative and positive weights in leaf node and do not boost them (experimental!) ]
##


#VAR -*-*-*-*-*-*-*-*-*-*-*-* variables *-*-*-*-*-*-*-*-*-*-*-*-

NVar 5
dijet_invmass                 dijet_invmass                 dijet_invmass                 m_{jj} [MeV]                                                    'F'    [40009.2421875,129989.242188]
dijet_deltaeta                dijet_deltaeta                dijet_deltaeta                #Delta#eta                                                      'F'    [3.93390655518e-06,3.26730585098]
leading_jet_pt                leading_jet_pt                leading_jet_pt                lead jet p_{T} [MeV]                                            'F'    [25222.3691406,527524.875]
subleading_jet_pt             subleading_jet_pt             subleading_jet_pt             sub jet p_{T} [MeV]                                             'F'    [25000.2109375,216794.3125]
leading_jet_eta               leading_jet_eta               leading_jet_eta               lead jet #eta                                                   'F'    [-4.48069095612,4.45503520966]
NSpec 0


============================================================================ */

#include <vector>
#include <cmath>
#include <string>
#include <iostream>

#define NN new BDTGNode
   
#ifndef BDTGNode__def
#define BDTGNode__def
   
class BDTGNode {
   
public:
   
   // constructor of an essentially "empty" node floating in space
   BDTGNode ( BDTGNode* left,BDTGNode* right,
                          int selector, double cutValue, bool cutType, 
                          int nodeType, double purity, double response ) :
   fLeft         ( left         ),
   fRight        ( right        ),
   fSelector     ( selector     ),
   fCutValue     ( cutValue     ),
   fCutType      ( cutType      ),
   fNodeType     ( nodeType     ),
   fPurity       ( purity       ),
   fResponse     ( response     ){
   }

   virtual ~BDTGNode();

   // test event if it decends the tree at this node to the right
   virtual bool GoesRight( const std::vector<double>& inputValues ) const;
   BDTGNode* GetRight( void )  {return fRight; };

   // test event if it decends the tree at this node to the left 
   virtual bool GoesLeft ( const std::vector<double>& inputValues ) const;
   BDTGNode* GetLeft( void ) { return fLeft; };   

   // return  S/(S+B) (purity) at this node (from  training)

   double GetPurity( void ) const { return fPurity; } 
   // return the node type
   int    GetNodeType( void ) const { return fNodeType; }
   double GetResponse(void) const {return fResponse;}

private:

   BDTGNode*   fLeft;     // pointer to the left daughter node
   BDTGNode*   fRight;    // pointer to the right daughter node
   int                     fSelector; // index of variable used in node selection (decision tree)   
   double                  fCutValue; // cut value appplied on this node to discriminate bkg against sig
   bool                    fCutType;  // true: if event variable > cutValue ==> signal , false otherwise
   int                     fNodeType; // Type of node: -1 == Bkg-leaf, 1 == Signal-leaf, 0 = internal 
   double                  fPurity;   // Purity of node from training
   double                  fResponse; // Regression response value of node
}; 
   
//_______________________________________________________________________
   BDTGNode::~BDTGNode()
{
   if (fLeft  != NULL) delete fLeft;
   if (fRight != NULL) delete fRight;
}; 
   
//_______________________________________________________________________
bool BDTGNode::GoesRight( const std::vector<double>& inputValues ) const
{
   // test event if it decends the tree at this node to the right
   bool result;
     result = (inputValues[fSelector] > fCutValue );
   if (fCutType == true) return result; //the cuts are selecting Signal ;
   else return !result;
}
   
//_______________________________________________________________________
bool BDTGNode::GoesLeft( const std::vector<double>& inputValues ) const
{
   // test event if it decends the tree at this node to the left
   if (!this->GoesRight(inputValues)) return true;
   else return false;
}
   
#endif
   
#ifndef IClassifierReader__def
#define IClassifierReader__def

class IClassifierReader {

 public:

   // constructor
   IClassifierReader() : fStatusIsClean( true ) {}
   virtual ~IClassifierReader() {}

   // return classifier response
   virtual double GetMvaValue( const std::vector<double>& inputValues ) const = 0;

   // returns classifier status
   bool IsStatusClean() const { return fStatusIsClean; }

 protected:

   bool fStatusIsClean;
};

#endif

class ReadBDTG : public IClassifierReader {

 public:

   // constructor
   ReadBDTG( std::vector<std::string>& theInputVars ) 
      : IClassifierReader(),
        fClassName( "ReadBDTG" ),
        fNvars( 5 ),
        fIsNormalised( false )
   {      
      // the training input variables
      const char* inputVars[] = { "dijet_invmass", "dijet_deltaeta", "leading_jet_pt", "subleading_jet_pt", "leading_jet_eta" };

      // sanity checks
      if (theInputVars.size() <= 0) {
         std::cout << "Problem in class \"" << fClassName << "\": empty input vector" << std::endl;
         fStatusIsClean = false;
      }

      if (theInputVars.size() != fNvars) {
         std::cout << "Problem in class \"" << fClassName << "\": mismatch in number of input values: "
                   << theInputVars.size() << " != " << fNvars << std::endl;
         fStatusIsClean = false;
      }

      // validate input variables
      for (size_t ivar = 0; ivar < theInputVars.size(); ivar++) {
         if (theInputVars[ivar] != inputVars[ivar]) {
            std::cout << "Problem in class \"" << fClassName << "\": mismatch in input variable names" << std::endl
                      << " for variable [" << ivar << "]: " << theInputVars[ivar].c_str() << " != " << inputVars[ivar] << std::endl;
            fStatusIsClean = false;
         }
      }

      // initialize min and max vectors (for normalisation)
      fVmin[0] = -1;
      fVmax[0] = 1;
      fVmin[1] = -1;
      fVmax[1] = 0.99999988079071;
      fVmin[2] = -1;
      fVmax[2] = 1;
      fVmin[3] = -1;
      fVmax[3] = 1;
      fVmin[4] = -1;
      fVmax[4] = 1;

      // initialize input variable types
      fType[0] = 'F';
      fType[1] = 'F';
      fType[2] = 'F';
      fType[3] = 'F';
      fType[4] = 'F';

      // initialize constants
      Initialize();

      // initialize transformation
      InitTransform();
   }

   // destructor
   virtual ~ReadBDTG() {
      Clear(); // method-specific
   }

   // the classifier response
   // "inputValues" is a vector of input values in the same order as the 
   // variables given to the constructor
   double GetMvaValue( const std::vector<double>& inputValues ) const;

 private:

   // method-specific destructor
   void Clear();

   // input variable transformation

   double fMin_1[3][5];
   double fMax_1[3][5];
   void InitTransform_1();
   void Transform_1( std::vector<double> & iv, int sigOrBgd ) const;
   void InitTransform();
   void Transform( std::vector<double> & iv, int sigOrBgd ) const;

   // common member variables
   const char* fClassName;

   const size_t fNvars;
   size_t GetNvar()           const { return fNvars; }
   char   GetType( int ivar ) const { return fType[ivar]; }

   // normalisation of input variables
   const bool fIsNormalised;
   bool IsNormalised() const { return fIsNormalised; }
   double fVmin[5];
   double fVmax[5];
   double NormVariable( double x, double xmin, double xmax ) const {
      // normalise to output range: [-1, 1]
      return 2*(x - xmin)/(xmax - xmin) - 1.0;
   }

   // type of input variable: 'F' or 'I'
   char   fType[5];

   // initialize internal variables
   void Initialize();
   double GetMvaValue__( const std::vector<double>& inputValues ) const;

   // private members (method specific)
   std::vector<BDTGNode*> fForest;       // i.e. root nodes of decision trees
   std::vector<double>                fBoostWeights; // the weights applied in the individual boosts
};

double ReadBDTG::GetMvaValue__( const std::vector<double>& inputValues ) const
{
   double myMVA = 0;
   for (unsigned int itree=0; itree<fForest.size(); itree++){
      BDTGNode *current = fForest[itree];
      while (current->GetNodeType() == 0) { //intermediate node
         if (current->GoesRight(inputValues)) current=(BDTGNode*)current->GetRight();
         else current=(BDTGNode*)current->GetLeft();
      }
      myMVA += current->GetResponse();
   }
   return 2.0/(1.0+exp(-2.0*myMVA))-1.0;
};

void ReadBDTG::Initialize()
{
  // itree = 0
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.595306,0.119425) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.363488,-0.163197) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.23637,-0.27759) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.130278,-0.392033) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.0383083,-0.445008) , 
3, -0.965295, 0, 0, 0.0989527,-0.401047) , 
0, 0.333339, 1, 0, 0.212297,-0.287703) , 
2, -0.91931, 0, 0, 0.306827,-0.193173) , 
3, -0.817045, 0, 0, 0.390126,-0.109874)    );
  // itree = 1
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.435682,-0.00765568) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.263547,-0.232412) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.212511,-0.330871) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.0709926,-0.349991) , 
3, -0.887518, 0, 0, 0.139056,-0.287704) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.0830293,-0.41639) , 
0, 0.754163, 1, 0, 0.117738,-0.308968) , 
4, -0.338483, 0, 0, 0.238944,-0.206407) , 
0, 0.428641, 1, 0, 0.395106,-0.0475974)    );
  // itree = 2
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.431061,0.0198698) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.261306,-0.186603) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.276468,-0.383027) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.238488,-0.227813) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.133477,-0.300104) , 
3, -0.93287, 0, 0, 0.17847,-0.215916) , 
3, -0.798338, 0, 0, 0.196073,-0.227281) , 
0, -0.7279, 0, 0, 0.227585,-0.192079) , 
0, -0.52381, 0, 0, 0.395703,-0.0202126)    );
  // itree = 3
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.50715,0.071096) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.307116,-0.0668845) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.222357,-0.14621) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.226512,-0.176455) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.0930547,-0.267527) , 
0, 0.286427, 1, 0, 0.167367,-0.170148) , 
3, -0.941064, 0, 0, 0.183796,-0.152678) , 
1, -0.142789, 1, 0, 0.264962,-0.0876784) , 
3, -0.90476, 0, 0, 0.390733,-0.0133219)    );
  // itree = 4
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.5087,0.068383) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.340129,-0.0362933) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.458435,-0.0345475) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.255564,-0.280367) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.137082,-0.175336) , 
3, -0.829194, 0, 0, 0.153766,-0.128376) , 
1, -0.262357, 1, 0, 0.21552,-0.108307) , 
0, 0.238023, 1, 0, 0.308138,-0.0494317) , 
2, -0.838283, 0, 0, 0.392018,-0.00759779)    );
  // itree = 5
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.427271,0.0170058) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.270616,-0.0831083) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.210432,-0.2112) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.127034,0.0149055) , 
1, 0.428571, 1, 0, 0.19845,-0.123376) , 
0, 0.705154, 1, 0, 0.229106,-0.0940503) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.0879739,-0.299258) , 
4, 0.417159, 1, 0, 0.211753,-0.105782) , 
0, 0.523707, 1, 0, 0.392584,-0.00605668)    );
  // itree = 6
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.442763,0.0433152) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.288612,-0.0971776) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.191423,-0.205463) , 
4, -0.434429, 0, 0, 0.279277,-0.0782588) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.193896,-0.335526) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.174719,-0.159305) , 
2, -0.892087, 0, 0, 0.182008,-0.159914) , 
4, 0.400211, 1, 0, 0.269655,-0.0863365) , 
0, -0.333221, 0, 0, 0.394881,-0.000713285)    );
  // itree = 7
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.810143,0.250126) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.392356,0.00100407) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.268173,-0.115693) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.126825,-0.337157) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.10557,-0.210215) , 
2, -0.918375, 0, 0, 0.116947,-0.191482) , 
4, -0.583692, 0, 0, 0.219336,-0.117305) , 
4, -0.421236, 0, 0, 0.374642,-0.0113483) , 
3, -0.451138, 0, 0, 0.392328,-0.00324761)    );
  // itree = 8
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.406361,0.0127147) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.224283,-0.268195) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.158965,-0.144451) , 
0, -0.336825, 0, 0, 0.198809,-0.173163) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.197121,-0.0767093) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.110314,-0.202102) , 
4, 0.620273, 1, 0, 0.152546,-0.0868604) , 
1, -0.168526, 1, 0, 0.179481,-0.137108) , 
4, 0.51473, 1, 0, 0.393738,0.000985283)    );
  // itree = 9
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.43395,0.026442) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.323999,-0.0549409) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.256198,-0.178316) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.112319,-0.13865) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.0870413,-0.0941047) , 
3, -0.946543, 0, 0, 0.0995825,-0.0519389) , 
1, 0.0483487, 1, 0, 0.193566,-0.0941476) , 
4, 0.310909, 1, 0, 0.299807,-0.0466794) , 
0, 0.238104, 1, 0, 0.392827,-0.000593364)    );
  // itree = 10
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.672521,0.0914875) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.383143,0.00533299) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.261739,-0.0362121) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.232288,-0.0921886) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.102584,-0.0800701) , 
0, 0.427296, 1, 0, 0.214144,-0.0628165) , 
3, -0.984452, 0, 0, 0.240823,-0.0413446) , 
3, -0.959184, 0, 0, 0.344467,-0.00841689) , 
3, -0.714285, 0, 0, 0.396006,0.00299014)    );
  // itree = 11
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.420342,0.00679173) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.290233,-0.215682) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.20334,-0.0674877) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.187581,0.00895792) , 
3, -0.982153, 0, 0, 0.199929,-0.030223) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.134568,-0.164682) , 
0, -0.963521, 0, 0, 0.193442,-0.0366483) , 
3, -0.812836, 0, 0, 0.211388,-0.0570844) , 
0, -0.619083, 0, 0, 0.393129,-0.00321234)    );
  // itree = 12
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.439111,0.0175884) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.315134,-0.0418103) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.212093,-0.213634) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.154027,-0.145458) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.127913,-0.0584032) , 
4, -0.458412, 0, 0, 0.140732,-0.0519318) , 
0, 0.454955, 1, 0, 0.165415,-0.0815941) , 
4, -0.333333, 0, 0, 0.288758,-0.0359098) , 
0, 0.238031, 1, 0, 0.392768,-0.00212332)    );
  // itree = 13
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.514098,0.0386012) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.36022,-0.004488) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.228114,-0.0476136) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.138274,-0.0941996) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.118757,-0.154331) , 
3, -0.973343, 1, 0, 0.12993,-0.0758756) , 
2, -0.969274, 0, 0, 0.201581,-0.0441823) , 
2, -0.928292, 0, 0, 0.293024,-0.0205851) , 
2, -0.849389, 0, 0, 0.393451,0.000748414)    );
  // itree = 14
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.41204,0.00763309) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.449116,-0.0155374) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.210187,-0.0831389) , 
3, -0.916392, 0, 0, 0.346144,-0.0289296) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.118365,-0.101166) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.113158,-0.238682) , 
1, -0.220619, 0, 0, 0.11606,-0.0918228) , 
4, 0.606092, 1, 0, 0.320284,-0.0359983) , 
4, 0.247864, 1, 0, 0.390629,-0.00437223)    );
  // itree = 15
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.414167,0.0162851) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.726532,0.0783112) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.374445,-0.0189235) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.168455,-0.0778824) , 
2, -0.934141, 0, 0, 0.324141,-0.0214411) , 
3, -0.619027, 0, 0, 0.355226,-0.0161236) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.0977833,-0.184382) , 
4, -0.635092, 0, 0, 0.335712,-0.0217936) , 
4, -0.209675, 0, 0, 0.393355,0.00236478)    );
  // itree = 16
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.43997,0.0187562) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.492617,-0.223505) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.409847,-0.0590845) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.277486,0.0146582) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.228604,-0.0336533) , 
4, -0.108598, 0, 0, 0.259156,-0.00192354) , 
3, -0.872194, 0, 0, 0.299099,-0.0123578) , 
3, -0.61641, 0, 0, 0.308544,-0.0186784) , 
0, -0.238095, 0, 0, 0.395157,0.00199097)    );
  // itree = 17
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.425967,0.00386188) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.265643,-0.118816) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.296581,-0.109599) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.198053,-0.0973432) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.146576,0.0402265) , 
2, -0.844983, 0, 0, 0.155772,0.00193807) , 
3, -0.75358, 0, 0, 0.179106,-0.0125231) , 
2, -0.808694, 0, 0, 0.215315,-0.0384958) , 
0, 0.523706, 1, 0, 0.390926,-0.00413668)    );
  // itree = 18
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.51801,0.017875) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.339753,0.0330953) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.255039,-0.0265195) , 
1, -0.815679, 1, 0, 0.266215,-0.0118148) , 
3, -0.904753, 0, 0, 0.397002,0.000798065) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.186319,-0.163049) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.0894852,-0.103255) , 
3, -0.895627, 0, 0, 0.145286,-0.0721612) , 
0, 0.904762, 1, 0, 0.389743,-0.00130585)    );
  // itree = 19
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.43358,0.013267) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.289628,-0.145362) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.249418,0.00511927) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.175827,-0.114205) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.153841,-0.00792425) , 
3, -0.951591, 0, 0, 0.166955,-0.0397925) , 
4, 0.318844, 1, 0, 0.234519,-0.00464723) , 
2, -0.780699, 0, 0, 0.245746,-0.0222243) , 
0, -0.428605, 0, 0, 0.391796,0.00208718)    );
  // itree = 20
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.531832,0.0285696) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.326198,0.00369152) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.422852,-0.0495605) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.519187,0.0710769) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.221282,-0.0117544) , 
1, -0.722908, 1, 0, 0.244479,-0.00139852) , 
0, 0.25164, 1, 0, 0.319766,-0.0175531) , 
0, -0.0476633, 1, 0, 0.323162,-0.00692579) , 
2, -0.809187, 0, 0, 0.393998,0.00163665)    );
  // itree = 21
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.408452,0.0130356) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.475378,-0.0344021) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.286488,0.0484739) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.232327,-0.0823724) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.136435,0.0237965) , 
0, 0.274463, 1, 0, 0.164953,-0.0109926) , 
2, -0.891394, 0, 0, 0.21281,0.00360704) , 
1, -0.169396, 1, 0, 0.369914,-0.012899) , 
0, 0.0476213, 1, 0, 0.391518,-0.000561951)    );
  // itree = 22
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.449153,0.0151814) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.277657,-0.0301252) , 
0, 0.333323, 1, 0, 0.406318,0.00370274) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.186567,-0.193664) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.160969,0.00335492) , 
0, -0.339791, 0, 0, 0.177443,-0.0864145) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.134892,0.0457008) , 
1, -0.137455, 1, 0, 0.161749,-0.0488643) , 
4, -0.52381, 0, 0, 0.394181,0.00109415)    );
  // itree = 23
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.438961,0.0106382) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.359078,-0.0784745) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.220011,0.0282304) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.222169,-0.0541645) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.20522,0.0358451) , 
4, -0.301134, 0, 0, 0.217866,-0.0211243) , 
4, 0.230027, 0, 0, 0.21845,-0.0112323) , 
3, -0.826664, 0, 0, 0.24804,-0.0198498) , 
0, -0.428576, 0, 0, 0.396757,0.001223)    );
  // itree = 24
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.4491,0.00581685) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.230646,0.00107239) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.417116,0.0148477) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.225022,-0.0828438) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.167881,-0.038224) , 
4, -0.192392, 0, 0, 0.199355,-0.0377237) , 
3, -0.838732, 0, 0, 0.225384,-0.0320278) , 
4, 0.212078, 0, 0, 0.226967,-0.0222147) , 
1, -0.171038, 1, 0, 0.393791,-0.00252543)    );
  // itree = 25
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.415384,0.0118114) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.472888,-0.164847) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.577887,0.0294603) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.372806,0.021545) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.247643,-0.0557553) , 
2, -0.795336, 0, 0, 0.268369,-0.0276349) , 
3, -0.766149, 0, 0, 0.317114,-0.0203997) , 
2, -0.569003, 0, 0, 0.324953,-0.0239026) , 
4, 0.247864, 1, 0, 0.394612,0.000522577)    );
  // itree = 26
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.767733,0.0634151) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.495101,0.0121168) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.296388,-0.00160345) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.244002,-0.0504621) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.207344,0.00114361) , 
0, -0.3331, 0, 0, 0.229057,-0.0183254) , 
3, -0.968889, 0, 0, 0.272788,-0.00710261) , 
3, -0.8911, 0, 0, 0.370983,-0.000263135) , 
3, -0.542615, 0, 0, 0.394941,0.00181611)    );
  // itree = 27
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.416533,0.00631731) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.47147,0.0391183) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.272393,-0.0750558) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.210638,0.0239029) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.135306,-0.0542233) , 
0, -0.145912, 1, 0, 0.170939,-0.00598514) , 
3, -0.941821, 0, 0, 0.23534,-0.0319663) , 
2, -0.756251, 0, 0, 0.276728,-0.0222671) , 
4, -0.333333, 0, 0, 0.394229,-3.19086e-05)    );
  // itree = 28
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.452428,-0.0483686) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.400921,0.00461449) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.399765,-0.066941) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.518696,0.0352745) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.290387,-0.0274702) , 
2, -0.773685, 0, 0, 0.339005,-0.0090061) , 
1, -0.731837, 1, 0, 0.349992,-0.0156654) , 
4, 0.137373, 1, 0, 0.383227,-0.00348124) , 
1, -0.907711, 1, 0, 0.389189,-0.00599796)    );
  // itree = 29
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.450232,-0.00865676) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.49183,0.128323) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.357483,-0.0334689) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.344411,-0.0658934) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.255536,0.0293009) , 
2, -0.817859, 0, 0, 0.262422,0.0121824) , 
1, -0.269669, 1, 0, 0.273689,0.00793597) , 
2, -0.760893, 0, 0, 0.291048,0.0135132) , 
1, -0.333193, 1, 0, 0.392486,0.00116955)    );
  // itree = 30
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.903391,0.171879) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.400922,-0.000187134) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.360234,0.0989997) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.173196,0.0150139) , 
3, -0.918628, 0, 0, 0.268246,0.0324077) , 
4, -0.460802, 0, 0, 0.391725,0.00213107) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.0534091,-0.182073) , 
4, -0.701994, 0, 0, 0.387862,0.00137823) , 
3, -0.142857, 0, 0, 0.393143,0.0021714)    );
  // itree = 31
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.433624,-0.00111482) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.390167,-0.091552) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.322123,-0.00260462) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.156277,-0.0367812) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.139987,-0.11194) , 
2, -0.963512, 1, 0, 0.152045,-0.0332837) , 
2, -0.954986, 0, 0, 0.278249,-0.00989717) , 
2, -0.765255, 0, 0, 0.298738,-0.0183878) , 
0, -0.238095, 0, 0, 0.387843,-0.00671936)    );
  // itree = 32
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.445859,0.00627375) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.273355,-0.0584645) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.193439,-0.0532742) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.175745,0.0340412) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.080842,-0.080598) , 
4, 0.400935, 1, 0, 0.158636,0.00812951) , 
3, -0.910953, 0, 0, 0.16735,-0.00097943) , 
1, 0.0395754, 1, 0, 0.2145,-0.0175409) , 
1, -0.171038, 1, 0, 0.38855,-0.00116182)    );
  // itree = 33
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.483029,0.0314785) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.394044,-0.00428143) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.288473,0.0501053) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.193527,-0.105796) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.170453,0.0106567) , 
2, -0.845314, 0, 0, 0.176757,-0.0111552) , 
0, -0.782113, 0, 0, 0.255716,0.0179709) , 
0, -0.428414, 0, 0, 0.367554,0.00120679) , 
1, -0.714286, 1, 0, 0.399129,0.00675684)    );
  // itree = 34
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.591926,-0.0226995) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.475661,0.104527) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.306475,0.0112375) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.309847,-0.00882436) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.148655,-0.0785699) , 
0, -0.618309, 0, 0, 0.286382,-0.0106725) , 
4, -0.046835, 0, 0, 0.297471,-0.000767247) , 
3, -0.843264, 0, 0, 0.311232,0.0048937) , 
3, -0.81714, 0, 0, 0.392876,-0.000654319)    );
  // itree = 35
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.421889,0.00644711) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.431904,-0.0503048) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.491503,0.0742837) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.247731,-0.0106488) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.138111,-0.0830374) , 
4, -0.263267, 0, 0, 0.220146,-0.0133932) , 
3, -0.771806, 0, 0, 0.262067,-0.00337023) , 
2, -0.809524, 0, 0, 0.331743,-0.0144462) , 
0, 0.14279, 1, 0, 0.388768,-0.00254039)    );
  // itree = 36
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.414531,0.00809351) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.277091,-0.0795336) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.258598,-0.0460234) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.132022,0.0313917) , 
1, -0.0346787, 1, 0, 0.211751,-0.0125936) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.161957,0.0885959) , 
3, -0.971159, 0, 0, 0.199872,-0.00158059) , 
1, -0.552401, 1, 0, 0.2263,-0.0174315) , 
4, -0.421236, 0, 0, 0.395629,0.00303274)    );
  // itree = 37
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.434952,0.0101816) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.622783,0.0760017) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.445369,-0.042079) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.282729,-0.00666037) , 
1, -0.619048, 1, 0, 0.322965,-0.0100322) , 
2, -0.51586, 0, 0, 0.340048,-0.00689068) , 
0, 0.142857, 1, 0, 0.399902,0.00187273) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.0834115,-0.142575) , 
4, 0.685454, 1, 0, 0.395313,0.000964989)    );
  // itree = 38
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.638326,-0.0241708) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.579557,0.0703021) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.481985,-0.0405338) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.442233,0.0302724) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.275221,-0.0078194) , 
3, -0.882221, 0, 0, 0.3153,0.00147098) , 
3, -0.809718, 0, 0, 0.329044,-0.000913871) , 
3, -0.764931, 0, 0, 0.342126,0.0016062) , 
3, -0.725569, 0, 0, 0.39162,-0.00104024)    );
  // itree = 39
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.58926,-0.112083) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.583913,0.0264759) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.582431,0.0123744) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.437829,-0.0891318) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.299598,-0.00890098) , 
3, -0.817328, 0, 0, 0.307947,-0.00918526) , 
3, -0.786846, 0, 0, 0.363546,-0.00569592) , 
2, -0.654137, 0, 0, 0.387053,-0.00348554) , 
2, -0.273646, 0, 0, 0.389544,-0.00420301)    );
  // itree = 40
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.41051,0.00459731) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.232856,0.0543252) , 
0, -0.722994, 0, 0, 0.399692,0.00451251) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.263556,0.0452655) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.218846,-0.0108928) , 
0, -0.950149, 0, 0, 0.240401,0.00874916) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.0795621,-0.15622) , 
2, -0.907387, 0, 0, 0.171677,-0.0224834) , 
0, -0.904762, 0, 0, 0.392132,0.00361739)    );
  // itree = 41
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.443209,0.0117178) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.332759,-0.0279935) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.319517,0.177738) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.155519,-0.121095) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.1277,0.0503932) , 
1, -0.523642, 1, 0, 0.131045,0.00668016) , 
0, 0.396857, 1, 0, 0.153258,0.0169489) , 
3, -0.912557, 0, 0, 0.264792,-0.00441677) , 
0, 0.333341, 1, 0, 0.398568,0.00484864)    );
  // itree = 42
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.431715,0.00285341) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.314909,-0.0369615) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.257536,-0.110411) , 
4, -0.310785, 0, 0, 0.309668,-0.0289232) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.227337,0.0680963) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.186941,-0.0622714) , 
1, -0.647236, 0, 0, 0.210592,0.00639304) , 
4, -0.43857, 0, 0, 0.300971,-0.0258229) , 
0, -0.238095, 0, 0, 0.386949,-0.00764796)    );
  // itree = 43
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.484242,0.0295566) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.66984,0.0700402) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.478873,-0.167453) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.579612,0.0405021) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.345183,-0.009945) , 
2, -0.672936, 0, 0, 0.362229,-0.00419198) , 
2, -0.541388, 0, 0, 0.363649,-0.00520552) , 
2, -0.49305, 0, 0, 0.374935,-0.00349628) , 
1, -0.819966, 1, 0, 0.393203,0.000392753)    );
  // itree = 44
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.558781,-0.0196451) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.704808,0.0819937) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.494997,0.0820574) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.348531,0.00318343) , 
2, -0.727253, 0, 0, 0.35093,0.00286363) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.0929853,-0.113423) , 
2, -0.986395, 0, 0, 0.346222,0.0017377) , 
3, -0.587096, 0, 0, 0.357899,0.0032734) , 
2, -0.714286, 0, 0, 0.393383,0.000756485)    );
  // itree = 45
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.444265,0.0101872) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.34268,-0.0439477) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.243606,-0.00892588) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.187558,0.105603) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.183777,0.0257479) , 
4, -0.000558978, 1, 0, 0.185641,0.0271763) , 
0, -0.777876, 0, 0, 0.229187,0.00249413) , 
2, -0.862829, 0, 0, 0.270186,-0.00845183) , 
0, -0.333339, 0, 0, 0.39589,0.0024358)    );
  // itree = 46
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.454568,-0.0210475) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.412181,0.0075309) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.226985,-0.0236503) , 
4, 0.431506, 1, 0, 0.394563,0.00328687) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.282191,0.148443) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.1112,-0.0310992) , 
3, -0.945799, 0, 0, 0.212837,0.0382613) , 
0, -0.904763, 0, 0, 0.389146,0.00432946) , 
1, -0.907893, 1, 0, 0.39485,0.00271954)    );
  // itree = 47
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.410304,-0.00310981) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.22113,-0.116157) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.16893,0.088288) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.171126,0.000432159) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.13719,-0.0949191) , 
0, -0.796381, 1, 0, 0.161046,-0.0141025) , 
4, -0.31119, 1, 0, 0.162491,-0.00518517) , 
3, -0.890282, 0, 0, 0.182974,-0.0270289) , 
0, -0.714267, 0, 0, 0.388215,-0.0044562)    );
  // itree = 48
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.616665,0.0236354) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.338774,-0.00653467) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.349262,0.0510224) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.270886,0.0731945) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.202694,-0.00912925) , 
2, -0.780038, 0, 0, 0.212346,0.000765065) , 
0, -0.460336, 0, 0, 0.247038,0.0099166) , 
0, -0.333119, 0, 0, 0.310322,9.76352e-05) , 
3, -0.809522, 0, 0, 0.395885,0.00414643)    );
  // itree = 49
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.408177,0.000863264) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.241381,-0.143569) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.222763,-0.0568171) , 
0, 0.909423, 1, 0, 0.232015,-0.0612011) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.157805,0.0651154) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.0875086,-0.0764173) , 
0, 0.900331, 1, 0, 0.125359,0.00151403) , 
3, -0.847722, 0, 0, 0.173152,-0.0265891) , 
0, 0.809548, 1, 0, 0.394375,-0.00103676)    );
  // itree = 50
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.427413,-0.00308527) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.294966,-0.0200156) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.236008,0.0874587) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.229475,0.0822293) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.143243,-0.051915) , 
1, -0.764328, 1, 0, 0.170288,-0.00317427) , 
0, -0.795824, 0, 0, 0.211101,0.0269716) , 
3, -0.869988, 0, 0, 0.235139,0.0157584) , 
0, -0.52381, 0, 0, 0.392993,0.00116728)    );
  // itree = 51
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.410541,0.00488154) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.607898,-0.0625825) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.32958,-0.0185036) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.474057,0.111978) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.25413,-6.5557e-06) , 
3, -0.834551, 0, 0, 0.28503,0.0113281) , 
0, -0.237905, 0, 0, 0.313763,-0.00346818) , 
3, -0.732628, 0, 0, 0.361111,-0.00861799) , 
4, -0.136989, 0, 0, 0.393623,-0.000877062)    );
  // itree = 52
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.463415,-0.00959478) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.389531,0.00348722) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.288185,-0.0457962) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.190337,0.14146) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.149287,0.0546015) , 
4, 0.0714411, 1, 0, 0.171525,0.0377042) , 
3, -0.791271, 0, 0, 0.19736,0.0228977) , 
0, 0.714275, 1, 0, 0.368733,0.00447677) , 
1, -0.723032, 1, 0, 0.393735,0.00158571)    );
  // itree = 53
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.672562,0.0345243) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.390469,0.00559385) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.262777,-0.043733) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.359325,0.0768979) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.2071,-0.00963365) , 
1, -0.44982, 1, 0, 0.220854,0.000201318) , 
1, -0.523649, 1, 0, 0.234813,-0.00963007) , 
3, -0.959184, 0, 0, 0.347822,9.48994e-05) , 
3, -0.714285, 0, 0, 0.39944,0.00316944)    );
  // itree = 54
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.494133,-0.0208896) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.338149,0.0508426) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.272153,0.00151754) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.200822,0.0201727) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.199576,-0.0589231) , 
4, 0.182213, 0, 0, 0.199956,-0.0211569) , 
3, -0.985068, 0, 0, 0.255476,-0.00415924) , 
3, -0.921591, 0, 0, 0.264766,8.99373e-05) , 
3, -0.908523, 0, 0, 0.389231,-0.00740268)    );
  // itree = 55
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.469667,0.0110286) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.376404,-0.0153816) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.368218,0.0771624) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.200982,0.00642328) , 
2, -0.824294, 0, 0, 0.229101,0.0107861) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.193801,-0.108769) , 
3, -0.957509, 1, 0, 0.226236,0.00458989) , 
3, -0.953018, 0, 0, 0.328442,-0.00523982) , 
1, -0.539465, 1, 0, 0.392491,0.000436217)    );
  // itree = 56
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.402897,0.00612251) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.414359,0.00306744) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.513195,-0.0716884) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.37894,-0.0435973) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.269472,-0.00683602) , 
0, -0.183658, 0, 0, 0.294268,-0.0109596) , 
2, -0.828536, 0, 0, 0.33977,-0.0184066) , 
1, -0.589512, 1, 0, 0.377077,-0.00817453) , 
0, -0.0475481, 0, 0, 0.39037,-0.00205743)    );
  // itree = 57
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.611209,0.0171398) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.40097,-0.067772) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.388531,0.0155078) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.26411,-0.0151627) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.187413,0.040305) , 
4, 0.429331, 1, 0, 0.254388,-0.00625026) , 
2, -0.870739, 0, 0, 0.307848,0.000358213) , 
2, -0.457767, 0, 0, 0.309509,-0.00044151) , 
3, -0.809522, 0, 0, 0.392072,0.00248802)    );
  // itree = 58
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.396847,-0.0147437) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.650297,-0.0901157) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.381336,0.0172713) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.39479,0.137555) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.242639,0.058778) , 
0, -0.203798, 0, 0, 0.305425,0.0603979) , 
1, -0.110936, 1, 0, 0.374326,0.0161419) , 
3, -0.597407, 0, 0, 0.390785,0.0123517) , 
0, -0.0476267, 0, 0, 0.393905,0.00139325)    );
  // itree = 59
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.62581,0.0386074) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.538084,0.0148239) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.41467,0.0487055) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.298339,-0.012938) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.243141,0.00848091) , 
4, -0.225686, 0, 0, 0.283763,-0.00506975) , 
3, -0.865773, 0, 0, 0.287717,-0.00391318) , 
3, -0.859054, 0, 0, 0.375675,0.000857221) , 
2, -0.619048, 0, 0, 0.39966,0.00284545)    );
   return;
};
 
// Clean up
inline void ReadBDTG::Clear() 
{
   for (unsigned int itree=0; itree<fForest.size(); itree++) { 
      delete fForest[itree]; 
   }
}
   inline double ReadBDTG::GetMvaValue( const std::vector<double>& inputValues ) const
   {
      // classifier response value
      double retval = 0;

      // classifier response, sanity check first
      if (!IsStatusClean()) {
         std::cout << "Problem in class \"" << fClassName << "\": cannot return classifier response"
                   << " because status is dirty" << std::endl;
         retval = 0;
      }
      else {
         if (IsNormalised()) {
            // normalise variables
            std::vector<double> iV;
            int ivar = 0;
            for (std::vector<double>::const_iterator varIt = inputValues.begin();
                 varIt != inputValues.end(); varIt++, ivar++) {
               iV.push_back(NormVariable( *varIt, fVmin[ivar], fVmax[ivar] ));
            }
            Transform( iV, -1 );
            retval = GetMvaValue__( iV );
         }
         else {
            std::vector<double> iV;
            int ivar = 0;
            for (std::vector<double>::const_iterator varIt = inputValues.begin();
                 varIt != inputValues.end(); varIt++, ivar++) {
               iV.push_back(*varIt);
            }
            Transform( iV, -1 );
            retval = GetMvaValue__( iV );
         }
      }

      return retval;
   }

//_______________________________________________________________________
inline void ReadBDTG::InitTransform_1()
{
   // Normalization transformation, initialisation
   fMin_1[0][0] = 40020.140625;
   fMax_1[0][0] = 129926.023438;
   fMin_1[1][0] = 40009.2421875;
   fMax_1[1][0] = 129989.242188;
   fMin_1[2][0] = 40009.2421875;
   fMax_1[2][0] = 129989.242188;
   fMin_1[0][1] = 0.000138491392136;
   fMax_1[0][1] = 2.89279413223;
   fMin_1[1][1] = 3.93390655518e-06;
   fMax_1[1][1] = 3.26730585098;
   fMin_1[2][1] = 3.93390655518e-06;
   fMax_1[2][1] = 3.26730585098;
   fMin_1[0][2] = 25338.15625;
   fMax_1[0][2] = 437150.40625;
   fMin_1[1][2] = 25222.3691406;
   fMax_1[1][2] = 527524.875;
   fMin_1[2][2] = 25222.3691406;
   fMax_1[2][2] = 527524.875;
   fMin_1[0][3] = 25000.4355469;
   fMax_1[0][3] = 216794.3125;
   fMin_1[1][3] = 25000.2109375;
   fMax_1[1][3] = 201091;
   fMin_1[2][3] = 25000.2109375;
   fMax_1[2][3] = 216794.3125;
   fMin_1[0][4] = -3.89020991325;
   fMax_1[0][4] = 4.17321681976;
   fMin_1[1][4] = -4.48069095612;
   fMax_1[1][4] = 4.45503520966;
   fMin_1[2][4] = -4.48069095612;
   fMax_1[2][4] = 4.45503520966;
}

//_______________________________________________________________________
inline void ReadBDTG::Transform_1( std::vector<double>& iv, int cls) const
{
   // Normalization transformation
   if (cls < 0 || cls > 2) {
   if (2 > 1 ) cls = 2;
      else cls = 2;
   }
   const int nVar = 5;

   // get indices of used variables

   // define the indices of the variables which are transformed by this transformation
   std::vector<int> indicesGet;
   std::vector<int> indicesPut;

   indicesGet.push_back( 0);
   indicesGet.push_back( 1);
   indicesGet.push_back( 2);
   indicesGet.push_back( 3);
   indicesGet.push_back( 4);
   indicesPut.push_back( 0);
   indicesPut.push_back( 1);
   indicesPut.push_back( 2);
   indicesPut.push_back( 3);
   indicesPut.push_back( 4);

   std::vector<double> dv(nVar);
   for (int ivar=0; ivar<nVar; ivar++) dv[ivar] = iv[indicesGet.at(ivar)];
   for (int ivar=0;ivar<5;ivar++) {
      double offset = fMin_1[cls][ivar];
      double scale  = 1.0/(fMax_1[cls][ivar]-fMin_1[cls][ivar]);
      iv[indicesPut.at(ivar)] = (dv[ivar]-offset)*scale * 2 - 1;
   }
}

//_______________________________________________________________________
inline void ReadBDTG::InitTransform()
{
   InitTransform_1();
}

//_______________________________________________________________________
inline void ReadBDTG::Transform( std::vector<double>& iv, int sigOrBgd ) const
{
   Transform_1( iv, sigOrBgd );
}
